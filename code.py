"""
Есть 90 человек. Каждый из этих 90 человек относится к одной из двух категорий.
Одни на все вопросы говорят правду, другие — всегда врут.
У каждого ровно 1 любимое блюдо из списка (макароны/пельмени/вареники).
Каждому задают три вопроса:
- Ваше любимое блюдо — макароны?
- Ваше любимое блюдо — пельмени?
- Ваше любимое блюдо — вареники?
Результаты получились такие:
на первый вопрос утвердительно ответило 45 человек,
на второй — 35,
на третий — 30.
Сколько человек всегда говорят правду?
"""
# Каждый правдивый ответит "да" на один вопрос, каждый лжец ответит "да" на два вопроса.
# Поэтому количество лжецов равно разности между количеством утвердительных ответов и количеством людей.

answer = 20

"""
Есть числа от трех до одиннадцати. Есть квадрат — 3 на 3 клетки:
а б в
г д е
ё ж з
(Буквы ничего не значат, кроме того, что числа не повторяются)
Можно ли расставить числа в клетки квадрата таким образом, что перемножения чисел в строках дает тот же результат, что и произведение чисел в столбцах с теми же номерами?
Если можно — расставьте, если нельзя — объясните почему.
"""
# Числа 7 и 11 являются простыми числами, а значит взаимно исключающими в строках, а поэтому должны стоять в диагонали.
# Цифра 9 забирает остальные множители на 3 и на 6. Поэтому должна стоять отдельно
answer_2 = [[7, 4, 6],
            [8, 11, 5],
            [3, 10, 9]]
"""
Ученые разработали новый материал неизвестной прочности. 
Они знают, что материал разбивается при падении с высоты от 1 метра до 5 000 метров. Но не знают, с какой именно высоты. 
Чтобы определить прочность, ученые поднимают предмет на некоторую высоту и сбрасывают его оттуда. 
Их задача — определить, начиная с какой именно высоты предмет начнет разбиваться.
Специальная платформа, с помощью которой они осуществляют эксперимент, скидывает предмет только с дискретных высот 
(1, 2, 3 ... 4999, 5000 метров — платформа не может скинуть предмет, например, с 2,5 метров. Точности в 1 метр ученым вполне достаточно).
При падении с высоты "n" метров предмет уничтожается. Если же его сбрасывали с высоты ниже "n", то его можно использовать в повторных экспериментах.
Нужно АБСОЛЮТНО ТОЧНО найти ту высоту, начиная с которой предметы разрушаются. Сделать это нужно за МИНИМАЛЬНО возможное число экспериментов.
У ученых при этом всего 2 предмета, но они абсолютно одинаковые. Каким образом этого можно достигнуть? Сколько экспериментов при этом максимально потребуется?
"""
# Задача может быть решена бинарным поиском. Соответственно ответ:
# A = log(n)

"""
В университетскую столовую пришли трое студентов купить пирожки.
 Один хочет купить треть всех имеющихся в столовой пирожков и еще 2 пирожка. 
 Другой хочет купить четверть от всех имеющихся пирожков и ещё 3 пирожка. 
 А третий хочет купить пятую часть всех пирожков и ещё 8 пирожков. 
 Если все трое купят столько пирожков, сколько планируют, 
то в столовой как раз закончатся все пирожки. Сколько пирожков есть в столовой? 
"""

"""Задачи"""


# Написать метод/функцию, который/которая на вход принимает массив городов.
# В качестве результата возвращает строку, где города разделены запятыми, а в конце стоит точка.
def cities(arr):
    """3 минута"""
    print(''.join(arr), end='.')


# Написать метод/функцию, который/которая на вход принимает число (float), а на выходе получает число,  округленное до пятерок.
def rounder(num):
    """1 минута"""
    print(round(num, 2))


# Написать метод/функцию, который/которая на вход принимает число (int), а на выходе выдает слово “компьютер”
# в падеже, соответствующем указанному количеству. Например, «25 компьютеров», «41 компьютер», «1048 компьютеров».
def make_end_in_word(num):
    """3 минуты"""
    word = 'компьютер'
    if num in range(10, 20):
        print(f'{num} {word}ов')
    elif num % 10 == 1:
        print(f'{num} {word}')
    elif num % 10 in [2, 3, 4]:
        print(f'{num} {word}а')
    elif num % 10 in [5, 6, 7, 8, 0]:
        print(f'{num} {word}ов')


# Написать метод/функцию, который/которая на вход принимает целое число,
# а на выходе возвращает то, является ли число простым (не имеет делителей кроме 1 и самого себя).
def is_prime(n):
    """3 минуты"""
    if n == 1:
        return False
    i = 2
    while i * i <= n:
        if n % i == 0:
            return False
        i = i + 1
    return True


# Написать метод, который определяет, какие элементы присутствуют в двух экземплярах
# в каждом из массивов (= в двух и более, причем в каждом).
# На вход подаются два массива. На выходе массив с необходимыми совпадениями.


def find_duplicates(arr1, arr2):
    """5 минут"""

    def get_duplicates(arr):
        unique = set()
        not_unique = []
        for i in arr:
            if i in unique:
                not_unique.append(i)
            unique.add(i)
        return not_unique

    duplicates_1 = get_duplicates(arr1)
    duplicates_2 = get_duplicates(arr2)
    return list(filter(lambda x: x in duplicates_2, duplicates_1))


assert find_duplicates([7, 17, 1, 9, 1, 17, 56, 56, 23],
                       [56, 17, 17, 1, 23, 34, 23, 1, 8, 1]) == [1, 17]


# Написать метод, который в консоль выводит таблицу умножения.
# На вход метод получает число, до которого выводит таблицу умножения.
# В консоли должна появиться таблица. Например, если на вход пришло число 5, то получим:
def get_table(num):
    """25. 5 минут задание, 20 выравнивание"""
    res = [[0] * (num + 1) for i in range(num + 1)]
    for i in range(1, num + 1):
        res[0][i] = i
        res[i][0] = i
    for i in range(1, num + 1):
        for j in range(1, num + 1):
            res[i][j] = res[0][j] * res[i][0]
    for i in res:
        print(*[f'{x:>2}' for x in i])
