### Простые алгоритмы


- [Сортировка выбором](https://github.com/Cooke64/DataStructureAndAlgorithms/blob/main/Sorting_methods/sort_selections.py)
> Проходим по массиву в поисках максимального элемента.
> Найденный максимум меняем местами с последним элементом.
> Неотсортированная часть массива уменьшилась на один элемент
> (не включает последний элемент, куда мы переставили найденный максимум).
> К этой неотсортированной части применяем те же действия
> — находим максимум и ставим его на последнее место в неотсортированной
> части массива.

- [Сортировка вставками](https://github.com/Cooke64/DataStructureAndAlgorithms/blob/main/Sorting_methods/insert_sort.py)
> Предполагается, что первый элемент списка отсортирован. Переходим к следующему элементу, обозначим его х. 
> Если х больше первого, оставляем его на своём месте. Если он меньше, копируем его на вторую позицию, а х устанавливаем как первый элемент.

> Переходя к другим элементам несортированного сегмента, 
> перемещаем более крупные элементы в отсортированном сегменте вверх по списку, 
> пока не встретим элемент меньше x или не дойдём до конца списка. 
> В первом случае x помещается на правильную позицию.
- [Сортировка подсчетом](https://github.com/Cooke64/DataStructureAndAlgorithms/blob/main/Sorting_methods/sort_by_count.py)
> Находим минимальное и максимальное значение в списке, далее получаем количество элементов
> разницей между максимальный элементом и минимальным, причем минимальный элемент на 1 больше для удоства отсчета с нуля 
> Заполняем промежуточный массив, где каждый элемент промежуточного это счетчик элементов в исходном.
> Далее цикл по количеству элементов, где внутренний цикл зависит от временного массива и его счетчика на конкретном элементе.
> в исходном массиве заменяем столько элементов, сколько в промежуточном указывает счетчик. И увеличиваем позицию в конце каждого шага промежуточного цикла.
> 